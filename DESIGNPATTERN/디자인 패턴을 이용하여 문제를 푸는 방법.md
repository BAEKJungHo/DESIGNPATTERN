# 디자인 패턴을 이용하여 문제를 푸는 방법

## 적당한 객체 찾기

객체지향 프로그램은 객체(Object)로 만든다. 객체는 데이터와 이 데이터에 연산을 가하는 프로시저(procedure)를 함께 묶은 단위이다.
프로시저를 일반적으로 메서드(method) 또는 연산(operation) 이라고 한다. 객체는 요청(request) 또는 메시지(message)를 사용자에게 받으면 연산을 수행한다.

객체지향 설계의 가장 어려운 부분은 시스템을 구성할 객체의 분할을 결정하는 것이다. 여러가지 요인을 고려해야하기 때문에 매우 어려운 작업이다.
고려해야할 요인에는 캡슐화, 크기 정하기, 종속성, 유연성, 성능, 진화, 재사용성 등이 있다.

설계 방법에는 주로 아래와 같은 방법들이 있다.

```
1. 문제 기술서를 작성하고 명사와 동사를 추출해서 각각을 클래스와 연산으로 만드는 방법
2. 시스템의 협력 관계나 책임성을 중심으로 설계하는 방법
3. 실세계를 모델로 만들고 이를 분석해 설계로 전이하는 과정에서 객체로 바꾸는 방법
```

객체지향 설계는 실세계와 대응 관계를 갖지 못할 때가 많다. 즉, 분석 모델의 객체는 실세계 객체들이지만, 설계 모델의 객체에는 배열, 리스트처럼 구현에 가까운 클래스들도 있다.
실세계를 그대로 반영하는 모델링만 강조하면 현재의 실세계를 반영할 수는 있지만, 미래의 실세계는 반영할 수 없다. 

설계 단계 동안 만들어야 하는 새로운 추상화는 설계의 유연성을 증진하기 위한 중요한 노력 중 하나이다.

## 객체의 크기 결정

객체의 크기를 결정하는것은 디자인 패턴에서 답을 얻을 수 있다.

퍼사드 패턴은 서브시스템을 어떻게 객체로 표현할 수 있는지 설명하고, 플라이급 패턴은 규모는 작지만 개수는 많은 객체를 다루는 방법을 설명한다. 
추상 팩토리 패턴과 빌더 패턴은 다른 객체를 생성하는 책임만 있는 객체를 만들어 낸다. 방문자 패턴과 명령 패턴은 요청을 자신이 처리하는 것이 아니라,
다른 객체나 객체 집합이 요청을 처리하여 구현하도록 책임지는 객체를 만들어낸다.

## 객체 인터페이스 명세

디자인 패턴은 인터페이스에 정의해야 하는 중요 요소가 무엇이고 어떤 종류의 데이터를 주고받아야 하는지 식별하여 인터페이스를 정의하도록 도와준다.
메멘토 패턴은 객체의 내부 상태를 어떻게 저장하고 캡슐화해야 하는지를 정의함으로써 객체가 나중에 그 상태로 복구할 수 있는 방법을 알려준다.
장식자 패턴과 프록시 패턴은 장식되고 중재되는 객체와 동일한 인터페이스를 갖도록 장식자 객체와 프록시 객체의 인터페이스를 요청한다.
즉, 프록시 객체의 인터페이스는 자신이 대리하는 다른 객체의 인터페이스와 동일하다는 것이다. 방문자 패턴에서 방문자 인터페이스는 방문자 객체가 방문하는
객체들의 클래스 인터페이스를 그 방문자 인터페이스에 모두 반영하도록 한다.

## 객체 구현 명세하기

어떤 객체의 구현은 클래스에서 정의한다. 클래스는 객체의 내부 데이터와 표현 방법을 명세하고, 그 객체가 수행할 연산을 정의한다.

## 재사용을 실현 가능한 것으로

객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은 `클래스 상속`, 그리고 `객체 합성(object composition)`이다.

클래스 상속을 서브클래싱 이라고 하며, 서브클래싱에 의한 재사용을 `화이트박스 재사용(white-box reuse)` 이라고 한다. 화이트박스는 내부를 볼 수 있다는 의미에서 나온 말이다. 상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기 때문에 화이트박스인 셈이다.

객체 합성은 클래스 상속에 대한 대안이다. 다른 객체를 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것을 의미한다. 객체를 합성하려면, 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해 두어야 한다. 이런 스타일의 재사용을 `블랙박스 재사용(black-box reuse)` 이라고 한다. 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용 되기 때문이다.

### 상속과 합성의 장단점

- 상속의 장점
  - 클래스 상속은 컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 된다.
  - 클래스 상속으로 부모 클래스의 구현을 쉽게 수정할 수도 잇는데, 서브클래스는 모든 연산이 아닌 일부만 재정의할 수도 있다.
- 상속의 단점
  - 런타임에 상속받은 부모 클래스의 구현을 변경할 수 없다.
  - 부모 클래스는 서브클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속 받는다.
  - 부모 클래스가 변경되면 서브클래스도 변경된다.
  - 상속은 부모 클래스의 구현이 서브클래스에 다 드러나는 것이기 때문에 상속은 캡슐화를 파괴한다고 주장하는 의견도 있다. 
  - 이러한 종속성은 유연성과 재사용성을 떨어뜨린다. 
    - 해결방법 : 추상 클래스에서만 상속을 받으면 된다. 이미 추상 클래스를 상속했다는 것은 구현이 아닌 인터페이스를 상속한 것이므로 구현 자체는 서브클래스가 정의하고, 구현이 변경되면 서브클래스만 변경하면 된다.
    
 

